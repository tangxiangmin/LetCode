/**
 * Created by admin on 2017/9/27.
 */
// 给定一个m*n大小、初始化为0的矩阵，然后执行系列操作，每次范围内的数字均+1，最后求最大数字的出现次数

// 思路：由于每次操作都是从左上角到对应坐标所覆盖矩阵的值+1，，则只需要记录最小所有操作中面积最小的矩阵的面积即可
var maxCount = function(m, n, ops) {
    ops.forEach(op=>{
        m = Math.min(m, op[0]);
        n = Math.min(n, op[1]);
    })

    return m*n;
};

// var ops = [[16,1],[14,3],[14,2],[4,1],[10,1],[11,1],[8,3],[16,2],[13,1],[8,3],[2,2],[9,1],[3,1],[2,2],[6,3]];
// var ops = [[2,2],[3,3]];
var ops = [[20,10],[26,11],[2,11],[4,16],[2,3],[23,13],[7,15],[11,11],[25,13],[11,13],[13,11],[13,16],[26,17]]
var res = maxCount(26, 17, ops);
console.log(res);